libfptu
==============================================
Fast Positive Tuples, aka "Позитивные Кортежи"
by [Positive Technologies](https://www.ptsecurity.ru).
*Всё будет хорошо. The Future will (be) Positive.*

Машинно-эффективный формат линейного представления небольших структур
данных для (де)сериализации, обмена сообщениями и размещения в
разделяемой памяти.

Machine-handy format for linear representation of small data structures
for (de)serialization, messaging and placement in shared memory.
English translation [by Google](https://translate.googleusercontent.com/translate_c?act=url&ie=UTF8&sl=ru&tl=en&u=https://github.com/leo-yuriev/libfptu/tree/devel)
and [by Yandex](https://translate.yandex.ru/translate?url=https%3A%2F%2Fgithub.com%2Fleo-yuriev%2Flibfptu%2Ftree%2Fdevel&lang=ru-en).

[![License](https://img.shields.io/badge/License-Apache%202.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)
[![Build Status](https://travis-ci.org/leo-yuriev/libfptu.svg?branch=devel)](https://travis-ci.org/leo-yuriev/libfptu)
[![Build status](https://ci.appveyor.com/api/projects/status/8617mtix9paivmkx/branch/devel?svg=true)](https://ci.appveyor.com/project/leo-yuriev/libfptu/branch/devel)
[![CircleCI](https://circleci.com/gh/leo-yuriev/libfptu/tree/devel.svg?style=svg)](https://circleci.com/gh/leo-yuriev/libfptu/tree/devel)
[![Coverity Scan Status](https://scan.coverity.com/projects/12919/badge.svg)](https://scan.coverity.com/projects/leo-yuriev-libfptu)


## Кратко

"Позитивные Кортежи" - это _простой_ формат представления небольших
структур данных в линейном, удобном для машины виде. Библиотека
_libfptu_ реализует поддержку формата "Позитивных кортежей",
предоставляя интерфейс C++14 и выше.

Можно сказать, что _libfptu_ предлагает гибкость JSON, скорость нативных
структур языка _C_, возможности boost::optional и boost::variant.
Однако, в некоторых сценариях _libfptu_ может оказаться неудобной и
несколько суровой, так как не предлагает возможностей, которые не могут
быть эффективно выполнены машиной.

В актуальной версии _libfptu_ появилась поддержка схемы данных и
предварительно размещенных полей (aka preplaced), включая привязку к
нативным структурам языка _C_.

Стоит также упомянуть возможность размещения и совместного использования
(чтения) кортежей в разделяемой памяти. С целью расширения этих
возможностей в актуальную версию _libfptu_ была импортирована часть
инфраструктуры управления разделяемыми буфера проекта 1Hippeus.

## Отличия от MessagePack, Protocol Buffers, BJSON

**1. Легковесность и удобство для машины.** Объём кода минимален, а
внутренняя структура линейна и проста.
 > "Позитивные кортежи" не предлагают лишнего, в том числе IDL и кодогенератор,
 > но могут быть также эффективны как нативные структуры, при этом поддерживая
 > строки и опциональные поля в одном линейном участке памяти.

**2. Нужно чуть больше места, в сравнении с MessagePack.** Данные хранятся
в нативном машинном представлении, без сжатия. Поэтому для каждого поля
_может_ потребоваться на 3-4 байта больше.
 > Тем не менее, следует аккуратно интерпретировать эти цифры. В экстремальном
 > случае, когда много 64-битных целочисленных полей с близкими к нулю
 > значениями, представление в _libfptu_ может потребовать до 12 раз больше
 > памяти в сравнении с MessagePack (1 байт в MessagePack, против 12 байт в
 > _libfptu_).

**3. Очень быстрый доступ.** _libfptu_ позволяет сочетать скорость
прямого доступа к полям традиционных структур и подход разреженных
множеств с эффективным поиском в индексе.
 > Для эффективного доступа к полям кортежа достаточно его "сырого"
 > представления "как есть" в линейном участке памяти, без какой-либо
 > подготовки, без каких-либо преобразований, изменений и манипуляций.
 > Получения поля из кортежа, в худшем случае сводится, к поиску его
 > дескриптора в заголовке. Что требует чтения лишь одной кэш-линии
 > для первых 15 полей и далее на каждые 16 последующих.
 > При необходимости доступ к полям может быть организован без накладных
 > расходов, с такой-же эффективностью как к полям нативных структур
 > определенных во время компиляции кода.

**4. Очень дешевая (де)сериализация.** _libfptu_ формирует и растит
кортеж как линейную последовательность байт, просто дописывая данных.
Поэтому (де)сериализация в "Позитивные Кортежи" магически быстрая и
дешевая.
 > Заполнение кортежа происходит без лишних операций, просто
 > однократным копированием данных в заранее выделенный буфер
 > достаточного размера. При этом сериализованное представление
 > всегда готово, доступ к нему сводится к получению указателя и
 > размера.

**5. Изменения дешевы.** В отличии от традиционных кортежей, поля можно
добавлять, удалять и перезаписывать, в том числе с изменением размера.
 > При этом в линейном представлении могут образовываться неиспользуемые
 > зазоры, а у вас появляется выбор: пожертвовать местом или
 > использовать процедуру дефрагментации, которая, в худшем случае,
 > не дороже однократного копирования содержимого кортежа.


Однако, "Позитивные Кортежи" не являются серебряной пулей и вероятно не
подойдут, если:

 * В структурах более 1000 полей;
 * Размер одной структуры более 200 килобайт;
 * Минимизация объема важнее скорости доступа и затрат на (де)сериализацию.

************************************************************************

## Обзор

"Позитивные кортежи"

_libfptu_ поддерживает кортежи размером до 250 килобайт и до 8 тысяч
_экземпляров_ полей. Поля внутри кортежей строго типизированы и
идентифицируются легковесными _токенами_, которые используются для
доступа к полям через API. Можно сказать, что токены являются
компактными именами полей в удобной для машины форме. В свою очередь,
справочник схемы обеспечивает трансляцию имен полей в токены.

Поля предлагаются двух видов: предварительно размещенные (preplaсed) и
свободные (loose). Основное отличие между ними в разных компромиссах
между скоростью доступа и расходуемым местом. Доступ к полям
производится единообразно, вне зависимости от вида поля.

### Preplaced Fields

Предварительно размещенные поля (aka preplaced) аналогичны полям в
структурах языка _C_ и физически всегда присутствуют, т.е. в кортеже
соответствующем некоторой схеме для preplaced-полей всегда выделяется
место. Зато координаты preplaced-поля в кортеже всегда известны.
Поэтому обращение к preplaced-полю не требует какого-либо поиска и
равнозначно чтению данных по смещению, которое хранится внутри токена.

Более того, накладные расходы доступа к preplaced-полям могут быть
сведены к нулю. Для этого следует определить в исходном коде определить
необходимые структуры, а для их полей сгенерировать статические
токен-классы посредством макроса `FPTU_TOKEN`. Тогда обращения к
preplaced-полям через такие статические токен-классы будет выполняться
через шаблонные inline-методы, которые будут свернуты компилятором в
непосредственный доступ к данным.

При необходимости _libfptu_ может эмулировать отсутствие
preplaced-полей. Для этого, в зависимости от типа данных, одно из
возможных значений поля резервируется для обозначения логической
"пустоты". Например, для целочисленных типов со знаком в качестве таких
DENIL-значению (designated NIL) используется крайнее отрицательное
значение (INT_MIN).

### Loose Fields

Свободные поля, наоборот, всегда опциональны и занимают место только при
присутствии в кортеже. Для присутствующих loose-полей в начале кортежа
поддерживается компактный индекс, в котором идентифицируется номером
поля и типом данных. Для поиска в индексе _libfptu_ использует как
последовательное сканирование с акселерацией SSE2/AVX/AVX2/AVX512, так и
сортировку с двоичным поиском.

При необходимости loose-поля могут многократно повторяться в кортеже,
образую таким образом _неупорядоченные_ итерируемые коллекции,
аналогично `repeated fields` в Protocol Buffers. Для этого определение
поля должно быть определено в схеме как "коллекция".

Внутри _libfptu_ добавление loose-поля в кортеж приводит к дозаписи
дескриптора в начало индекса и дозаписи данных в конец кортежа.
Обращение к loose-полю сводится к поиску соответствующего дескриптора в
индексе, а затем чтению его значению по хранимому в дескрипторе
смещения.

Удаление loose-полей, а также обновление значений полей вариативной
длины (строки, бинарные строки, вложенные кортежи), может приводить к
образованию внутри кортежа неиспользуемых участков, которые
ликвидируются дефрагментацией. Такая дефрагментация не дороже
однократного копирования кортежа и не является обязательной.

### Типы данных

Набор типов зафиксирован и включает все распространенные нативные
(машинные) типы, а также строки, дата/время, произвольные
последовательности байт, IP-адреса, IP-сети, MAC-адреса и дайджесты.

Полный набор типов зафиксирован в определении `enum fptu::genus`, здесь
же стоит упомянуть некоторые особенности:

- `text` = Строки UTF8 длиной до 262129 байт. Во внутреннем
представлении длина строк хранится в явном виде, терминирующий ноль
не используется, но допустим внутри строк.

- `varbin` = Произвольные последовательности байт (бинарные строки)
размером до 262128 байт.

- `property` = Пара из однобайтового идентификатора и небольшого
бинарного объекта (последовательность байт) размером до 253 байт.

- `datetime_utc` = Дата/время в форме 32-битного беззнакового целого
числа секунд с начала Unix-эпохи 1970-01-01 00:00:00 +0000 (UTC).

- `datetime_h100` = Дата/время в форме фиксированной точки 32-dot-32
унифицированной с "Positive Hiper100re".

- `decimal` = 64-битное дробное в форме [плавающей точки с десятичной
экспонентой](https://en.wikipedia.org/wiki/Decimal_floating_point).

- `bin96`..`bin512` = Бинарный блоки размером
96/128/160/192/224/256/320/384/512 бит.

- `app_reserved_64` и `app_reserved_128` = зарезервированные за
приложением типы размером 64 и 128 бит.

Предусматривается вложенность кортежей, но в угоду легковесности и
производительности не предлагает для этого элегантного автоматизма. В
целом, для представления вложенных структур возможны два подхода:

1. Проекция, проще говоря, расширение имен:
   делаем `{ "ФИО.Имя": "Иван", "ФИО.Фамилия": "Петров" }`
   вместо `{ "ФИО": { "Имя": "Иван", "Фамилия": "Петров" } }`

2. Вложенная сериализация, когда сначала отдельно формируется кортеж с
   `"ФИО"`, а затем целиком вкладывается в родительский кортеж.

### Токены доступа

### Справочник схемы

### Коллекции и итераторы

~Можно проитерировать все поля в кортеже, это быстро и дешево:~

 * Можно итерировать с фильтрацией по тегу/номеру
   и битовой маске типов;
 * При итерации у каждого поля можно спросить тэг/номер,
   тип и значение;
 * Итератор остается валидным до разрушения или до
   компактификации кортежа;
 * При итерации любое количество полей можно как удалить,
   так и добавить;
 * Добавленные в процессе итерации поля можно как увидеть
   через итератор, так и не увидеть.

Однако, следует считать, что порядок полей при итерации не определен и
никак не связан с их порядком добавления или удаления. В частности,
поэтому нет (и не будет) итерации в обратном порядке.


************************************************************************

## Использование

### Устойчивость к некорректным данным

Постоянная проверка корректности данных слишком дорога и как-правило
избыточна. С другой стороны, любые нарушениях в десериализуемых данных
не должны приводить к авариям.

Поэтому в _libfptu_ эксплуатируется следующий принцип:

1. Доступны функции верификации сериализованной и изменяемой форм
кортежа, которые вы используете по своему усмотрению.

2. В угоду производительности, основные функции выполняют только
минимальный контроль корректности аргументов и предоставляемых данных.
Поэтому при мусорных (не валидных) данных их поведение не определено.

3. Гарантируется, что прошедшие проверку данные не вызовут нарушений при
дальнейшей работе с ними.

************************************************************************

## Внутри

### Формат

Физически кортеж представляет собой линейный участок памяти, в начале
которого расположен компактный индекс для быстрого доступа к
опциональным полям. Сразу за индексом располагаются полезные данные,
т.е. собственно значения полей кортежа. Таким образом, как сериализация,
так десериализация кортежа равноценны однократному
чтению/записи/копированию линейного участка памяти.

Формат представления кортежей ориентирован на машину. Все данные в
бинарном машинном виде, порядок байт строго нативный (определяется
архитектурой или режимом работы CPU):

 * сначала идет "заголовок", представляющий собой массив из 32-битных
   дескрипторов loose-полей;
 * за заголовком следуют данные полей;
 * каждый элемент-дескриптор в массиве-заголовке содержит идентификатор
   поля, **тип данных** и **смещение** к ним относительно дескриптора;
 * каждый дескриптор и связанные с ним данные выровнены на 4х-байтовую границу.


Для полей типа `fptu_uint16` смещение используется для хранения
непосредственно самого значения поля.

Строки хранятся только в UTF-8 с терминирующим `'\0'` без явной длины.
Это позволяет иметь классический "C" API и экономить на хранении длины,
а в остальных случаях использовать бинарные строки.

Для всех полей переменной длины (массивов, бинарных строк, вложенных
кортежей), за исключением C-строк, в первом 32-битном слове данных
хранится их размер. Причем в первом полуслове хранится брутто-размер
поля в 32-битных словах, а во втором в зависимости от типа:
 * точный размер для бинарных строк;
 * количество элементов для массивов и кортежей;
 * дополнительные признаки для кортежей;

Массивы хранятся как линейная последовательность образующих их
элементов. При этом их элементы выравниваются на 4-байтную границу,
кроме строк и `uint16`. Строки в массивах располагаются в стык, а
`uint16_t` просто последовательно.

Формат первого слова для вложенных кортежей и корневого кортежа
полностью совпадает с небольшой оговоркой:
  * В самостоятельном виде пустой кортеж может быть представлен
    как `ноль байт` (пустой строкой байт), так и минимальным заголовком,
    в котором указано `ноль элементов`.
  * Вложенный кортеж является полем, поэтому всегда обязан иметь
    заголовок c информацией о своем  нулевом размере.


### Изменяемая и сериализованная формы

Сериализованная форма кортежа _libfptu_ - это линейный участок памяти,
который одновременно является массивом 32-битных ячеек. В начале
располагается информация о количестве полей/колонок и общем размере
кортежа. Далее следует список дескрипторов, а за ним значения полей.

Создание и наполнение кортежа происходит в слегка отличающейся
"изменяемой" форме - это также линейный участок памяти, но выделенный с
учетом ожидаемого размера кортежа и дополнительного места для нескольких
служебных счетчиков. Проще говоря, изменяемая форма кортежа является
"обложкой" создаваемого сериализованного кортежа, но с резервирования
дополнительного места:

 * изменяемая форма кортежа живет в буфере, который выделяется в расчете
   на ожидаемый размер (как по количеству элементов, так и по их данным);
 * внутри выделенного буфера располагаются служебные счетчики, а также
   растет сериализованная форма кортежа;
 * получение сериализованной формы из изменяемой сводится к формированию
   информации о текущем размере кортежа и возврате указателя на его начало;
 * получение изменяемой формы из сериализуемой сводится к копированию
   кортежа внутрь выделенного буфера, размер которого должен включать запас
   на служебные счетчики и добавляемые данные.


         buffer of sufficient size
        |<=======================================================>|
        |                                                         |
        |   head         pivot                             tail   |
        |   <-----~~~~~~~~~|~~~~~~~~~~~~~~~~~~---------------->   |
        |       descriptors|payload                               |
                           |
                  #_D_C_B_A_aaa_bb_cccccc_dddd
                  |                          |
                  |<========================>|
                    linear uint32_t sequence
                       for serialization


